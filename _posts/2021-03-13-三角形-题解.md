# 三角形 题解

## 题目
### 题目描述
现在工厂里有三根铁棒，分别长为a，b，c，现在你可以对其中一些铁棒进行加长，但总的加长长度不能超过L并且 每次加长必须是整数，问有多少种加长的方案使得加长后的铁棒可以构成三角形。

### 输入
共一行，包含4 个整数a,b,c,L (1≤a,b,c≤3e5, 0≤L≤3e5)。 

### 输出
一行一个整数表示答案 

### 样例输入
输入样例1:
1 1 1 2
输入样例2:
1 2 3 1
输入样例3:
10 2 1 7

### 样例输出
输出样例1: 4
输出样例2: 2
输出样例3: 0

### 数据范围限制
对于30%的数据： a,b,c<=100 对于另外20%的数据： L<=10 对于100%的数据: 1<=a,b,c<=3e5,0<=L<=3e5

## 思路
先使用隔板法办法求出所有可能，再筛掉一些不合法的，剩下的就是答案
>隔板法就是在n个元素间插入(b-1)个板，即把n个元素分成b组的方法。
>因为这里分成的四份中都是可以为空的，所以这里把l加上4就可以巧妙地把题目改成至少一个，也就是不能为空，要求的时候再把4减去即可，但应为这里是求方案数，所以可以不用减4 
  公式：
    方案数=C(n-1,b);这是不能为空的情况，要为空可改成 C(n+b-1,b); 
    代码中b为3的原因是只用找三份，不需要第四份 

## 具体方法
  令x+y+z<=l（把x,y,z分别加在三条边上） 
  枚举x、y、z（如果a+x+b+y<=c+z则这个三角形不合法）
  最后枚举三次右边的c即可 

  当构不成三角形时: a+x+b+y<=c+z
  又∵x+y+z<=l
  ∴x+y<=(l-z)或(c+z-a-b)
  ∴x+y<=min(l-z,c+z-a-b)
  ∴max(x+y)=min(l-z,c+z-a-b) 
  现在枚举z求出最大的x+y，再一次用隔板法就可以求出来方案数了 
   
## CODE
```cpp
  #include<bits/stdc++.h>
  #define ll long long
  using namespace std;
  ll a,b,c,l,ans;
  ll work(ll x,ll y,ll z,ll w)
  {
    ll s=x+y+z+w,sub=0;
    ll t;
    for(int i=0;i<=w;i++)
    {
      t=min(s-i-x,i+x);
      if(y+z<=t)
      {
        sub+=(t-y-z+1)*(t-y-z+2)/2;//隔板法求方案数 推导懂了就行，我在这里就不写了 
      }
    }
    return sub;	
  }
  int main()
  {   scanf("%lld%lld%lld%lld",&a,&b,&c,&l);
      ans=(l+1)*(l+2)*(l+3)/6;//推导：ans=C(l+4-1,3)（4表示把l分成四份，其中三份给a,b,c,剩余一份留给自己，至于3表示的放在下面了）=(l-3)! / 3!*l! = l!*(l+1)*(l+2)*(l+3) / 6*l! = (l+1)*(l+2)*(l+3)/6
      ans-=work(a,b,c,l);
      ans-=work(b,a,c,l);
      ans-=work(c,b,a,l);
      printf("%lld",ans);
  }
```
