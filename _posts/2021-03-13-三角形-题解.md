
```cpp
  #include<bits/stdc++.h>
  #define ll long long
  using namespace std;
  ll a,b,c,l,ans;
  ll work(ll x,ll y,ll z,ll w)
  {
    ll s=x+y+z+w,sub=0;
    ll t;
    for(int i=0;i<=w;i++)
    {
      t=min(s-i-x,i+x);
      if(y+z<=t)
      {
        sub+=(t-y-z+1)*(t-y-z+2)/2;//隔板法求方案数 推导懂了就行，我在这里就不写了 
      }
    }
    return sub;	
  }
  int main()//思路：先求出所有可能，再筛掉一些不合法的，剩下的就是答案 
  {   scanf("%lld%lld%lld%lld",&a,&b,&c,&l);
      ans=(l+1)*(l+2)*(l+3)/6;//使用隔板法  推导：ans=C(l+4-1,3)（4表示把l分成四份，其中三份给a,b,c,剩余一份留给自己，至于3表示的放在下面了）=(l-3)! / 3!*l! = l!*(l+1)*(l+2)*(l+3) / 6*l! = (l+1)*(l+2)*(l+3)/6
      ans-=work(a,b,c,l);
      ans-=work(b,a,c,l);
      ans-=work(c,b,a,l);
      printf("%lld",ans);
  }
  /*
  令x+y+z<=l（把x,y,z分别加在三条边上） 
  枚举x、y、z（如果a+x+b+y<=c+z则这个三角形不合法）
  最后枚举三次右边的c即可 

  当构不成三角形时: a+x+b+y<=c+z
  又∵x+y+z<=l
  ∴x+y<=(l-z)或(c+z-a-b)
  ∴x+y<=min(l-z,c+z-a-b)
  ∴max(x+y)=min(l-z,c+z-a-b) 
  现在枚举z求出最大的x+y，再一次用隔板法就可以求出来方案数了 

  补充一下隔板法：
   隔板法就是在n个元素间插入(b-1)个板，即把n个元素分成b组的方法。

  因为这里分成的四份中都是可以为空的，所以这里把l加上4就可以巧妙地把题目改成至少一个，也就是不能为空，要求的时候再把4减去即可，但应为这里是求方案数，所以可以不用减4 
  公式：
    方案数=C(n-1,b);这是不能为空的情况，要为空可改成 C(n+b-1,b); 
    代码中b为3的原因是只用找三份，不需要第四份 
  */
```
